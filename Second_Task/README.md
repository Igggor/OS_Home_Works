# Первая задача **Runsim**:
## Условие задачи:
>Напишите программу runsim, которая осуществляет контроль количества одновременно работающих Unix-приложений, запущенных с её помощью. Программа читает имя Unix-команды со стандартного ввода и запускает её на выполнение. Количество одновременно работающих команд не должно превышать N, где N – параметр командной строки при запуске runsim. При попытке запустить более чем N приложений выдайте сообщение об ошибке и продолжите ожидание ввода команд на исполнение. Программа runsim должна прекращать свою работу при возникновении признака конца файла на стандартном вводе.

## Основная идея работы

При запуске программы ей передаётся единственный параметр — число N, определяющее максимально допустимое количество одновременно работающих процессов. Далее программа в цикле читает строки со стандартного ввода. Каждая строка интерпретируется как команда Unix, которую нужно выполнить.

Если число активных процессов меньше N, команда запускается в отдельном дочернем процессе с помощью системных вызовов `fork()` и `execvp()`.

Если же количество уже работающих процессов достигло значения N, программа не запускает новую команду, а выводит сообщение об ошибке:

```bash

[Error]: too many processes running (N)

```

После чего продолжает ожидать следующей команды от пользователя.

При завершении любого дочернего процесса используется неблокирующий вызов `waitpid()` с флагом `WNOHANG` для уменьшения счётчика работающих процессов.

Когда стандартный ввод закрывается, программа выходит из основного цикла, но перед завершением ожидает завершения всех оставшихся дочерних процессов.



ДЛя подсчёта активных процессов используется переменная running, которая увеличивается при создании дочернего процесса и уменьшается при его завершении.

При запуске команды через `fork()` создаётся новый процесс, а в дочернем процессе используется `execvp()` для выполнения введённой команды.

### Обработка превышения лимита процессов
Перед каждым запуском команды программа проверяет:

```c
if (running >= N)
    fprintf(stderr, "Error: too many processes running (%d)\n", running);
```

### Обработка завершения дочерних процессов
Чтобы "*собирать зомби*", используется:

```c
waitpid(-1, NULL, WNOHANG);
```


Обработка EOF
Когда `fgets()` возвращает `NULL`, программа прекращает чтение команд и ожидает завершения всех дочерних процессов.

## Как компилировать и запускать
Компиляция
```bash
gcc runsim.c -o runsim
```
## Запуск программы

Пример: ограничение одновременно работающих процессов — 3

```bash
./runsim 3
```


После запуска программы можно просто вводить команды построчно:
```bash
sleep 5
ls
sleep 10
uname -a

```
Каждая команда будет запускаться в отдельном процессе (если не превышен лимит N).

### Поведение при превышении лимита процессов

Если в данный момент уже запущено N процессов, новая команда не выполняется, а программа сообщает:
```bash
[Error]: too many processes running (3)
```

При этом программа не завершает работу — она продолжает ждать следующую команду.

---
---

# Вторая задача :
## Постановка задачи:
> 