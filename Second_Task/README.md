# Первая задача **Runsim**:
## Условие задачи:
>Напишите программу runsim, которая осуществляет контроль количества одновременно работающих Unix-приложений, запущенных с её помощью. Программа читает имя Unix-команды со стандартного ввода и запускает её на выполнение. Количество одновременно работающих команд не должно превышать N, где N – параметр командной строки при запуске runsim. При попытке запустить более чем N приложений выдайте сообщение об ошибке и продолжите ожидание ввода команд на исполнение. Программа runsim должна прекращать свою работу при возникновении признака конца файла на стандартном вводе.

## Основная идея работы

При запуске программы ей передаётся единственный параметр — число N, определяющее максимально допустимое количество одновременно работающих процессов. Далее программа в цикле читает строки со стандартного ввода. Каждая строка интерпретируется как команда Unix, которую нужно выполнить.

Если число активных процессов меньше N, команда запускается в отдельном дочернем процессе с помощью системных вызовов `fork()` и `execvp()`.

Если же количество уже работающих процессов достигло значения N, программа не запускает новую команду, а выводит сообщение об ошибке:

```bash

[Error]: too many processes running (N)

```

После чего продолжает ожидать следующей команды от пользователя.

При завершении любого дочернего процесса используется неблокирующий вызов `waitpid()` с флагом `WNOHANG` для уменьшения счётчика работающих процессов.

Когда стандартный ввод закрывается, программа выходит из основного цикла, но перед завершением ожидает завершения всех оставшихся дочерних процессов.



ДЛя подсчёта активных процессов используется переменная running, которая увеличивается при создании дочернего процесса и уменьшается при его завершении.

При запуске команды через `fork()` создаётся новый процесс, а в дочернем процессе используется `execvp()` для выполнения введённой команды.

### Обработка превышения лимита процессов
Перед каждым запуском команды программа проверяет:

```c
if (running >= N)
    fprintf(stderr, "Error: too many processes running (%d)\n", running);
```

### Обработка завершения дочерних процессов
Чтобы "*собирать зомби*", используется:

```c
waitpid(-1, NULL, WNOHANG);
```


Обработка EOF
Когда `fgets()` возвращает `NULL`, программа прекращает чтение команд и ожидает завершения всех дочерних процессов.

## Как компилировать и запускать
Компиляция
```bash
gcc runsim.c -o runsim
```
## Запуск программы

Пример: ограничение одновременно работающих процессов — 3

```bash
./runsim 3
```


После запуска программы можно просто вводить команды построчно:
```bash
sleep 5
ls
sleep 10
uname -a

```
Каждая команда будет запускаться в отдельном процессе (если не превышен лимит N).

### Поведение при превышении лимита процессов

Если в данный момент уже запущено N процессов, новая команда не выполняется, а программа сообщает:
```bash
[Error]: too many processes running (3)
```

При этом программа не завершает работу — она продолжает ждать следующую команду.

---
---






# Вторая задача — *Моделирование работы посудомоечной станции двумя процессами*

## **Общая идея работы**

Программа запускается в двух процессах:

- **washer** - моет посуду
- **dryer** -  вытирает посуду

Механизм передачи зависит от выбранного `mode`:

```bash
pipe | fifo | msg | shm | sock | file_sem
```

Выполнение происходит слудующим образом:

1. **Процесс washer**:

   - считывает файл грязной посуды (`dirty.txt`)
   - для каждого элемента определяет время мойки
   - моет нужное количество секунд
   - размещает предмет на стол (через IPC)
   - если стол заполнен — ожидает освобождения
   - по завершению отправляет специальный EOF-маркер

2. **Процесс dryer**:

   - получает предметы через IPC-механизм
   - читает время вытирания из файла (`dry_times.txt`)
   - вытирает
   - после EOF - завершает работу

3. В режиме **shm** используется кольцевой буфер и набор семафоров:

   - `mutex` - защита разделяемой памяти
   - `empty` - количество пустых слотов
   - `full` - количество заполненных слотов

4. В варианте **file_sem** используется:

   - файл с циклическим буфером
   - 3 именованных семафора (`mutex`, `empty`, `full`)

5. Остальные режимы (`pipe`, `fifo`, `msg`, `sock`) используют соответствующие системные вызовы:

   - `pipe`, `mkfifo`, `msgsnd/msgrecv`, `socketpair`

В любом режиме должна соблюдается синхронизация, отсутствие гонок данных и корректное завершение на EOF.

---

## **Компиляция**

Программа собирается командой:

```bash
gcc -O2 dishwasher.c -o dishwasher -lrt
```

Флаг `-lrt` я использую для POSIX-семафоров и shm.

---

# **Запуск программы**

Формат:

```bash
./dishwasher <mode> wash_times.txt dry_times.txt dirty.txt
```

Где `mode` — один из следующих вариантов:

```bash
pipe | fifo | msg | shm | sock | file_sem
```

Например:

```bash
./dishwasher shm wash_times.txt dry_times.txt dirty.txt
```

Перед запуском должна быть установлека переменная окружения `TABLE_LIMIT`:

```bash
export TABLE_LIMIT=3
```

---

## **Упрощенный запуск через `run.sh`**

Для удобства я написал `bash-скрипт`:
(Тут уже скрипт сам поставит значение `TABLE_LIMIT` - ограничение посуды на столе, равное пяти)
```bash
./run.sh <mode>
```

Где `mode` — один из следующих вариантов:

```bash
pipe | fifo | msg | shm | sock | file_sem
```


Например:

```bash
./run.sh fifo
```

Скрипт автоматически делает:

- проверку режима
- установку `TABLE_LIMIT`
- запуск основной программы

---

## **Небольшое описание работы различных режимов**

### **1. SHM + семафоры**

Используется:

- `shmget`, `shmat`, `shmdt`, `shmctl`
- `semget`, `semop`
- кольцевой буфер в shared memory

Семафоры:

| № | Назначение |
| - | -------- |
| 0 | mutex - критическая секция |
| 1 | empty - свободные слоты |
| 2 | full - занятые слоты |

### **2. file_sem**

Используется:

- обычный файл как буфер
- три именованных семафора (`sem_open`)

Файл содержит:

```bash
header: in, out, cap
slots[cap]
```

### **3. pipe**

Однонаправленный неименованный канал.
Один процесс пишет, второй читает.

### **4. FIFO**

Именованный pipe (файл на ФС).
Используют `mkfifo`, `open`, `read`, `write`.

### **5. msgqueue**

Используются System V message queues:

- `msgsnd`
- `msgrcv`

Каждое сообщение содержит тип + строку с названием посуды.

### **6. Unix Sockets**

Создаётся пара сокетов через `socketpair()`, используется bidirectional канал.

---
---
---
---